#!/usr/bin/env bash
#
# truenas-update-all.sh
#
# Updates both TrueNAS app charts AND Docker images while preserving Tailscale Serve.
# - Uses TrueNAS CLI (midclt) to update app charts
# - Uses Watchtower to update Docker images
# - Backs up and restores Tailscale Serve configuration
#

set -euo pipefail

export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

STATE_DIR="/mnt/zfs_tank/scripts/state"
SERVE_JSON="${STATE_DIR}/tailscale-serve.json"
LOG_FILE="${STATE_DIR}/truenas-update-all.log"
WT_IMAGE="nickfedor/watchtower"
WT_ENV=(
  "-e" "TZ=Europe/Berlin"
  "-e" "WATCHTOWER_NOTIFICATIONS_HOSTNAME=TrueNAS"
  "-e" "WATCHTOWER_CLEANUP=true"
  "-e" "WATCHTOWER_INCLUDE_STOPPED=true"
)

TAILSCALE_READY_TIMEOUT=30
STABILIZATION_WAIT=60

mkdir -p "$STATE_DIR"

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

error() {
  log "ERROR: $*" >&2
  exit 1
}

if ! command -v docker &> /dev/null; then
  error "Docker command not found. PATH=$PATH"
fi

detect_tailscale_container() {
  local container_name
  container_name=$(docker ps --format '{{.Names}}\t{{.Image}}' | grep -i 'tailscale/tailscale' | head -n1 | cut -f1)
  if [[ -n "$container_name" ]]; then
    echo "$container_name"
    return 0
  fi
  container_name=$(docker ps --format '{{.Names}}' | grep -i tailscale | head -n1)
  if [[ -n "$container_name" ]]; then
    echo "$container_name"
    return 0
  fi
  while IFS= read -r name; do
    if docker exec "$name" which tailscale &>/dev/null; then
      echo "$name"
      return 0
    fi
  done < <(docker ps --format '{{.Names}}')
  return 1
}

log "Auto-detecting Tailscale container..."
TS_CONTAINER_NAME=$(detect_tailscale_container) || error "Could not auto-detect Tailscale container."
log "Detected Tailscale container: $TS_CONTAINER_NAME"

ts() { 
  docker exec "$TS_CONTAINER_NAME" tailscale "$@"
}

wait_for_tailscale() {
  local timeout=$1
  local elapsed=0
  log "Waiting for Tailscale to be ready (timeout: ${timeout}s)..."
  while [[ $elapsed -lt $timeout ]]; do
    if ts status >/dev/null 2>&1; then
      log "Tailscale is ready"
      return 0
    fi
    sleep 2
    elapsed=$((elapsed + 2))
  done
  error "Tailscale did not become ready within ${timeout}s"
}

check_container() {
  if ! docker ps --format '{{.Names}}' | grep -q "^${TS_CONTAINER_NAME}$"; then
    error "Container '$TS_CONTAINER_NAME' is not running"
  fi
}

backup_serves() {
  log "==> Backing up current Tailscale Serve configuration"
  if ts serve status --json > "${SERVE_JSON}.tmp" 2>/dev/null; then
    if grep -q '"TCP"' "${SERVE_JSON}.tmp" && ! grep -q '"TCP": {}' "${SERVE_JSON}.tmp"; then
      mv "${SERVE_JSON}.tmp" "${SERVE_JSON}"
      port_count=$(grep -oP '"[0-9]+":' "${SERVE_JSON}" | wc -l)
      log "Backed up $port_count ports to ${SERVE_JSON}"
      cp "${SERVE_JSON}" "${SERVE_JSON}.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
      find "$STATE_DIR" -name "tailscale-serve.json.*" -type f 2>/dev/null | sort -r | tail -n +11 | xargs -r rm -f
    else
      log "WARN: No active Tailscale Serve ports found in JSON"
      rm -f "${SERVE_JSON}.tmp"
    fi
  else
    log "WARN: Could not backup serve config; continuing with existing backup"
    rm -f "${SERVE_JSON}.tmp"
  fi
}

restore_serves() {
  if [[ ! -f "${SERVE_JSON}" ]]; then
    log "WARN: No JSON backup found at ${SERVE_JSON} - skipping restore"
    return 0
  fi
  if [[ ! -s "${SERVE_JSON}" ]]; then
    log "WARN: JSON backup is empty - skipping restore"
    return 0
  fi
  local ports
  ports=$(grep -oP '"([0-9]+)":\s*\{' "${SERVE_JSON}" | grep -oP '[0-9]+' | sort -n | uniq)
  if [[ -z "$ports" ]]; then
    log "WARN: No ports found in JSON backup - skipping restore"
    return 0
  fi
  local port_count
  port_count=$(echo "$ports" | wc -l)
  log "==> Restoring Tailscale Serve configuration for $port_count ports"
  local success_count=0
  local fail_count=0
  for port in $ports; do
    if docker exec "$TS_CONTAINER_NAME" tailscale serve --bg --https="$port" "http://127.0.0.1:$port" >> "$LOG_FILE" 2>&1; then
      success_count=$((success_count + 1))
    else
      fail_count=$((fail_count + 1))
      log "WARN: Failed to configure port $port"
    fi
  done
  log "Configured $success_count of $port_count ports successfully"
  if [[ $fail_count -gt 0 ]]; then
    log "WARN: $fail_count ports failed to configure"
  fi
}

update_truenas_charts() {
  log "==> Checking for TrueNAS app updates..."
  
  if ! command -v midclt &> /dev/null; then
    log "WARN: midclt not found - skipping TrueNAS chart updates"
    return 0
  fi
  
  # Get list of apps with available updates
  local apps_to_update
  apps_to_update=$(midclt call app.query | jq -r '.[] | select(.upgrade_available == true) | .name' 2>/dev/null || true)
  
  if [[ -z "$apps_to_update" ]]; then
    log "No TrueNAS app updates available"
    return 0
  fi
  
  local app_count
  app_count=$(echo "$apps_to_update" | wc -l)
  log "Found $app_count app(s) with updates: $(echo $apps_to_update | tr '\n' ' ')"
  
  for app in $apps_to_update; do
    log "Updating TrueNAS app: $app"
    if midclt call app.upgrade "$app" '{"app_version": "latest"}' >> "$LOG_FILE" 2>&1; then
      log "Successfully started upgrade for: $app"
    else
      log "WARN: Failed to upgrade: $app"
    fi
  done
  
  # Wait for upgrades to complete
  log "Waiting for TrueNAS app upgrades to complete..."
  local wait_count=0
  local max_wait=60  # 5 minutes max (60 * 5 seconds)
  
  while [[ $wait_count -lt $max_wait ]]; do
    local deploying
    deploying=$(midclt call app.query | jq -r '.[] | select(.state == "DEPLOYING") | .name' 2>/dev/null || true)
    
    if [[ -z "$deploying" ]]; then
      log "All TrueNAS app upgrades completed"
      break
    fi
    
    log "Still deploying: $(echo $deploying | tr '\n' ' ') (${wait_count}/${max_wait})"
    sleep 5
    wait_count=$((wait_count + 1))
  done
  
  if [[ $wait_count -ge $max_wait ]]; then
    log "WARN: Timeout waiting for app upgrades to complete"
  fi
}

run_watchtower() {
  log "==> Running Watchtower (run-once)"
  if ! docker run --rm \
    -v /var/run/docker.sock:/var/run/docker.sock \
    "${WT_ENV[@]}" \
    "$WT_IMAGE" --run-once 2>&1 | tee -a "$LOG_FILE"; then
    log "WARN: Watchtower encountered errors"
  fi
}

# Main
log "=========================================="
log "==> TrueNAS + Watchtower Update Script"
log "=========================================="
log "==> Using Tailscale container: $TS_CONTAINER_NAME"

check_container

if ! ts version >/dev/null 2>&1; then
  error "Cannot communicate with Tailscale"
fi

backup_serves

log "==> Stopping Tailscale Serve listeners"
ts serve reset || log "WARN: Failed to reset serve (may not be configured)"

# Update TrueNAS charts first
update_truenas_charts

# Then run Watchtower for Docker image updates
run_watchtower

log "==> Waiting ${STABILIZATION_WAIT} seconds for containers to stabilize..."
sleep "$STABILIZATION_WAIT"

log "==> Re-detecting Tailscale container after updates..."
NEW_CONTAINER=$(detect_tailscale_container) || error "Could not find Tailscale container after update"

if [[ "$NEW_CONTAINER" != "$TS_CONTAINER_NAME" ]]; then
  log "Container name changed: $TS_CONTAINER_NAME -> $NEW_CONTAINER"
  TS_CONTAINER_NAME="$NEW_CONTAINER"
else
  log "Container name unchanged: $TS_CONTAINER_NAME"
fi

check_container
wait_for_tailscale "$TAILSCALE_READY_TIMEOUT"
restore_serves

sleep 2
log "==> Checking Tailscale Serve status"
if ts serve status >/dev/null 2>&1; then
  log "==> Tailscale Serve is active"
  active_count=$(ts serve status --json 2>/dev/null | grep -oP '"[0-9]+":' | wc -l || echo 0)
  log "Active serves: $active_count ports"
else
  log "WARN: No Tailscale Serve configuration active"
fi

log "==> Script completed successfully"
exit 0
